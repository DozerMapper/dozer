<document>
  <properties>
    <author email="fgarsombke@yahoo.com">Franz Garsombke</author>
    <title>Collection and Array Mapping</title>
  </properties>
  <head>
    <meta http-equiv="CACHE-CONTROL" name="CACHE-CONTROL" CONTENT="NO-CACHE" />
    <meta http-equiv="PRAGMA" name="PRAGMA" CONTENT="NO-CACHE" />
    <META HTTP-EQUIV="EXPIRES" CONTENT="0" />
  </head>
  <body>
    <section name="Collection and Array Mapping">
      <p>
        Dozer automatically maps between collection types and automatically performs any type conversion. Each
        element in the source collection is mapped to an element in the dest object. Hints are used to specify what
        type of objects are created in the destination collection. The following collection mapping is
        automatically handled by Dozer: (These are all bi-directional)
      </p>
      <ul>
        <li>List to List</li>
        <li>List to Array</li>
        <li>Array to Array</li>
        <li>Set to Set</li>
        <li>Set to Array</li>
        <li>Set to List</li>
      </ul>
      <subsection name="Using Hints for Collection Mapping">
        <p>
          Hints are not required if you are using JDK 1.5 Generics or Arrays because the types can be autodetected
          by Dozer. But if you are not using generics or Arrays, to convert a Collection/Array to a
          Collection/Array with different type objects you can specify a Hint to let Dozer know what type of
          objects you want created in the destination list. If a Hint is not specified for the destination field,
          then the destination Collection will be populated with objects that are the same type as the elements in
          the src Collection.
        </p>
        <br/>
        <source>
          <![CDATA[ 
<field>
  <a>hintList</a> <!-- converting TheFirstSubClass List to TheFirstSubClassPrime List -->
  <b>hintList</b> 
  <b-hint>net.sf.dozer.vo.TheFirstSubClassPrime</b-hint> 
</field>    
            ]]>
        </source>
        <p>
          Below is a summary of the mapping logic used when mapping Arrays, Sets, and Lists. This gives a breakdown
          of what happens when hints are or are not used.
          <ul>
            <li>List to List</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
              <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
            </ul>
          </ul>
          <ul>
            <li>Array to List</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
              <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
            </ul>
          </ul>
          <ul>
            <li>List to Array</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest array will contain data types defined by the array</li>
              <li>
                If hint is speficied: Dest list will contain objects that match dest hint(s) type (only if Object
                Array)
              </li>
            </ul>
          </ul>
          <ul>
            <li>Array to Array</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest array will contain data types defined by the array</li>
              <li>
                If hint is speficied: Dest list will contain objects that match dest hint(s) type (only if Object
                Array)
              </li>
            </ul>
          </ul>
          <ul>
            <li>Set to Set</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
              <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
            </ul>
          </ul>
          <ul>
            <li>Array to Set</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
              <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
            </ul>
          </ul>
          <ul>
            <li>Set to Array</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest array will contain data types defined by the array</li>
              <li>
                If hint is speficied: Dest list will contain objects that match dest hint(s) type (only if Object
                Array)
              </li>
            </ul>
          </ul>
          <ul>
            <li>List to Set</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
              <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
            </ul>
          </ul>
          <ul>
            <li>Set to List</li>
            <ul>
              <li>Dest Hint req'd: NO</li>
              <li>Dest Hint allowed: YES</li>
              <li>If no dest hint specified: Dest list will contain the same data types in the source</li>
              <li>If hint is speficied: Dest list will contain objects that match dest hint(s) type</li>
            </ul>
          </ul>
        </p>
      </subsection>
      <subsection name="Using JDK 1.5 Generics for Collection Mapping">
        <p>
          Hints are not required when JDK 1.5 Generics are used. To convert a Collection/Array to a
          Collection/Array with different type objects dozer can determine parameterized types at runtime.
        </p>
        <source>
          <![CDATA[ 
public class UserGroup {

  private Set<User> users;

  public Set<User> getUsers() {
    return users;
  }

  public void setUsers(Set<User> aUsers) {
    users = aUsers;
  }

}
public class UserGroupPrime {

  private List<UserPrime> users;

  public List<UserPrime> getUsers() {
    return users;
  }

  public void setUsers(List<UserPrime> aUsers) {
    users = aUsers;
  }

}
            ]]>
        </source>
      </subsection>

      <subsection name="Object Array to List (bi-directional)">
        <p>
          When converting an Object array to a List, by default the destination List will contain the same data
          type as the source Array.
        </p>
        <source>
          <![CDATA[ 
<field>
  <a>arrayForLists</a><!-- changing an Integer [] to List and back again -->
  <b>listForArray</b>
</field>    
            ]]>
        </source>
        <p>
          Use a hint for data type conversion. Because a hint is specified, the destination List will contain
          String elements instead of Integers.
        </p>
        <source>
          <![CDATA[ 
<field>
  <a>arrayForLists</a><!-- changing an Integer [] to List and back again -->
  <b>listForArray</b>
  <b-hint>java.lang.String</b-hint> 
</field>    
            ]]>
        </source>
      </subsection>
      <subsection name="Primitive Array to Primitive Array (bi-directional)">
        <p>
          When converting an Object array to an Array, by default the destination Array will contain the same data
          type as the source Array.
        </p>
        <source>
          <![CDATA[ 
<field>
  <a>anArray</a> <!-- converting int[] to int [] by name only -->
  <b>theMappedArray</b>
</field>      
            ]]>
        </source>
      </subsection>
      <subsection name="Cumulative vs. Non-Cumulative List Mapping (bi-directional)">
        <p>
          If you are mapping to a Class which has already been initialized, dozer will either &apos;add&apos; or
          &apos;update&apos; objects to your List. If your List or Set already has objects in it dozer checks the
          mapped List, Set, or Array and calls the contains() method to determine if it needs to &apos;add&apos; or
          &apos;update&apos;. This is determined using the relationship-type attribute on the field tag. The
          default is &apos;cumulative&apos;. relationship-type can be specifed at the field mapping, class mapping,
          or global configuration level.
        </p>
        <br></br>
        <p>global configuration level....</p>
        <source>
          <![CDATA[ 
<mappings>
  <configuration>
     <relationship-type>non-cumulative</relationship-type>
  </configuration>
</mappings>
            ]]>
        </source>
        <p>class mapping level....</p>
        <source>
          <![CDATA[ 
<mappings>
  <mapping relationship-type="non-cumulative">
    <class-a>net.sf.dozer.vo.TestObject</class-a>
    <class-b>net.sf.dozer.vo.TestObjectPrime</class-b>
    <field>
      <a>someList</a>
      <b>someList</b>
    </field>    
  </mapping> 
</mappings>            ]]>
        </source>
        <p>field mapping level....</p>
        <source>
          <![CDATA[ 
<field relationship-type="cumulative">
  <a>hintList</a> <!-- objects will always be added to an existing List -->
  <b>hintList</b> 
  <a-hint>net.sf.dozer.vo.TheFirstSubClass</a-hint> 
  <b-hint>net.sf.dozer.vo.TheFirstSubClassPrime</b-hint> 
</field>    

<field relationship-type="non-cumulative">
  <a>unequalNamedList</a> <!-- objects will updated if already exist in List, added if they are not present -->
  <b>theMappedUnequallyNamedList</b> 
</field>    
            ]]>
        </source>

      </subsection>
      <subsection name="Removing Orphans">
        <p>
          Orphans are elements which exist in a destination collection that did not exist within the source
          collection.

          Dozer will remove orphans by calling the &apos;remove&apos; method on actual orphans of the underlying
          destination collection; it will not clear all. To determine elements which are orphans dozer uses the
          contains() method to check if the results contains orphans. The default is false.
        </p>
        <source>
          <![CDATA[ 
<field remove-orphans="true">
  <a>srcList</a> 
  <b>destList</b>  <!-- orphan objects will always be removed from an existing destination List -->
</field>    
            ]]>
        </source>
      </subsection>

    </section>
  </body>
</document>